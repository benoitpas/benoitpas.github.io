---
layout: post
title: How does my tree look in Dotty ?
---

It is an exercise I use with candidates as a starting point for discussion. First I ask them to model a binary tree and then we work together on how to write a function that adds a unique identifier to all nodes of the tree.

![hierarchy1.png]({{ site.baseurl }}/_posts/_2020-11-7-Dotty/hierarchy1.png)
![hierarchy1.png]({{ site.baseurl }}/images/hierarchy1.png)
![_config.yml]({{ site.baseurl }}/images/config.png)
A few things we can explore with this exercise are:

* How to model the tree ? (the main 2 different approaches are either to use a terminal Leaf node and a  node that has to have a left and right branch or use a node with 1 optional left branch and one optional right branch). it is a good way to discuss when to use optional (and not to use them !).

* Shall use a case class or a normal class ? Why choose one other the other ?

* How to store any type in the tree ? There is possibility here to discuss the use of the 'Any' type versus generics.

* When thinking of the function that adds the id, how to add it ? Return a tuple containing an id and the node is the most elegant but we could imagine to use an interface as well. Here it is possible to discuss more advanced use of generics and how comfortable  is the person with them.

* Then when implementing the actual function, it is interesting to see how the person thinks around recursivity.

* Usually the easiest way to add a unique id is to choose an integer. One difficulty is how to make sure each the same integer does not get reused, which means first ids need to be allocated to one branch, usually the left one and then the right one which means the algorithm cannot be parallelized.

* We could imagine using other solutions for the id, like a string describing the position of the node in the tree (like 'llr' for Left-Left-Right), which main advantage is that it can be parallelized. We can then discuss disadvantages, like with this solution if the position of the nodes cannot be changed, i.e. it is possible to add or remove nodes  but if the tree is rebalanced then the id of the nodes will change (which may or may not be a problem depending on how the ids are used)

So to learn more about [Dotty](https://dotty.epfl.ch/), I decided to use it to implement a solution to this little problem.

The main difference between the Scala solution and the Dotty one is how the tree is modelled. In both cases I use [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type).

_Need to add code for Scala/Dotty_

The sum is always represented as a case class but in Dotty, it is possible to use enums for the product.  As explained by [Martin Odersky](https://github.com/lampepfl/dotty/issues/1970), using enums allows a lighter syntax: in Scala 2.x, the trait used for the product has to be 'sealed' and the case classes 'final'.

The actual implementation of the function is similar in Scala and Dotty. 

_Need to add code for function__

Enums are one of the rare language feature which was present in Java but not in Scala. Java has parameterized enum [since Java 5](https://docs.oracle.com/javase/1.5.0/docs/guide/language/enums.html) while in Scala 2.x they are implemented in the [standard library](https://www.scala-lang.org/api/current/scala/Enumeration.html).

Enums in Dotty are a useful addition, they will make building ADT based data structure clearer and easier to read.

*Notes:*
* Scala example available here:
* Dotty example available here: